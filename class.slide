Introduction to Go
Go for Perl Programmers (or non-Perl Programmers)
11 Jun 2015

Dave Rolsky
autarch@urth.org
http://blog.urth.org/

* Introductions

* Are You Prepared?

- Do you have a laptop?
- ... with Go 1.4 installed?
- ... and the ability to run shell scripts?
- ... and your text editor of choice?
- ... and the tarball for this class?

* Goals for This Class

- Provide a broad overview of Go
- Touch on many parts of the language
- Cannot cover the language in depth
- This is a first step, not the final step

* Go Versus Perl

- Compiled versus interpreted
- Static (inferenced) typing versus dynamic
- C-esque syntax (with some reminders of Perl 6)
- Packaging and libraries are *very* different from Perl (more on this later)

* Why Use Go?

- It's fast
- Concurrency baked into the language
- Good built-in libraries and a decent selection of third-party libraries
- It's statically compiled so deployment is trivial

  jane@machine:~/go/src/github.com/jane/my-app> go build
  jane@machine:~/go/src/github.com/jane/my-app> cp my-app /path/to/deployment

- And you can cross-compile too!

  jane@machine:~/go/src/github.com/jane/my-app> GOOS=windows GOARCH=amd64 go build

- Produces a *my-app.exe* file

* Why Go Sucks

- A little too easy to ignore errors
- Concurrency is somewhat low-level - Go is no Erlang
- No algebraic data types (`Collection<X>` where `X` is a type)

* Hello, World

.play gopath/src/github.com/autarch/intro-to-go-class-code/hello-world1/hello-world1.go

* Hello, World Again

.play gopath/src/github.com/autarch/intro-to-go-class-code/hello-world2/hello-world2.go

* $GOPATH, Toolchain, and the Ecosystem

* $GOPATH

- All your Go code lives under `$GOPATH`
- Mine is `~/go`

    ~/go
    ├── bin
    ├── pkg
    └── src

- Installed executables go in `bin`
- Compiled libraries in `pkg`
- Source code in `src`
- `$GOPATH` is a colon-separated list

* Source Code Organization

- Source is identified by a repo path
- `~/go/src/github.com/google/go-github`
- `~/go/src/code.google.com/p/go-uuid`
- Both your code and third-party packages

* Starting a New Go Project

- Pick a repo
- Make a directory like `~/go/src/repo-host.com/username/repo-name`
- Hack, hack, hack

* Packages, Repos, and Paths

.play gopath/src/github.com/autarch/intro-to-go-class-code/uuid-example/uuid-example.go

    > cd $GOPATH/src
    > mkdir -p github.com/autarch
    > cd github.com/autarch
    > git clone https://github.com/autarch/intro-to-go-class-code
    > cd intro-to-go-class-code/uuid-example
    > go get

- Downloads `uuid` package to `gopath/src/code.google.com/p/go-uuid`

* The Toolchain

- The `go` program does most of the work
- `go`get` - download packages
- `go`build` - create an executable for specified package in place
- `go`install` - create an executable for specified package and put it in `$GOPATH/bin`
- `go`run` - run the specified code
- `go`test` - run tests for the specified package
- `go`fmt` - runs `gofmt` tool on specified package
- `go`vet` - runs `govet` tool on specified package

* More Tools

.link https://github.com/golang/lint golint
- Suggests fixes - in particular will catch places where you ignore errors
.link https://github.com/tools/godep godep
- Dependency management tool - we will cover this in depth later

* Links to Open Now

.link http://golang.org/pkg/ Built-in Package docs - http://golang.org/pkg/
.link http://golang.org/doc/effective_go.html Effective Go - http://golang.org/doc/effective_go.html
.link http://golang.org/ref/spec Language Spec - http://golang.org/ref/spec

* Goal The First

- Learn enough of the language to write a basic program
- (Not "Hello, World")

* Syntax in a Nutshell

- It's mostly like C, Perl, Ruby, JavaScript, and many others
- No semi-colons at end of line
- Variable assignment with `=`
- Comparisons with `==`, `<`, `>`, etc.
- Math operators are `+`, `-`, `*`, `/`, etc.
- Comments are `//` (single line) or `/*`delimited`*/`
- If we don't cover it explicitly, assume it's what you'd think it would be

* Go Naming Conventions

- Variables and functions: CamelCase and camelCase, not snake_case
- Constants: same thing
- If function or constant starts with a capital letter, it's exported
- Same for package-scoped variables

     package foo

     var Foo = 42
     var bar = 84

     const Pi = 3.14
     const realPi = 3.14159

     func internalOnly() ...
     func Exported() ...

* Variable Declarations

- Two ways to declare
- `var foo string = "bar"`
- `var` name, type, optional assignment
- `foo := 42` - short declaration syntax
- Short declaration implies type

    // Go knows this is an int
    foo := 42
    // Go looks at the return value of uuid.NewUUID() - it's a uuid.UUID
    id := uuid.NewUUID()

* Scope and Re-declaration

- Variables are always lexically scoped from where they're declared
- The lexical scope for control structures is the structure block (more on that later)
- Can redeclare variables declared with short declaration
- Can only-redeclare if we're also creating a new var

* Declaration Examples

.play gopath/src/github.com/autarch/intro-to-go-class-code/declarations/redeclare-ok.go

* Declaration Examples

.play gopath/src/github.com/autarch/intro-to-go-class-code/declarations/redeclare-bad.go

* Built-in Types

- boolean - `true` and `false`
- `uint`, `uint8`, 16, 32, 24
- `int`, `int8`, 16, 32, 24
- `float32`, `float64`
- `complex`, `complex32`, `complex64`
- `string` - Unicode everywhere - "foo, 酒廊"
- `rune` - one Unicode code point - '廊'
- `byte` - a single 8-bit value
- `[4]string` - array of 4 strings
- `[]string` - slice of strings
- structs, pointers, maps, channels, interfaces, function types - all covered later

* Working With Arrays and Slices

- They are 0-indexed
- Use the `len` built-in to check the length of an array or slice

    size := len(array)

- Access elements with square brackets:

    val0 := array[0]

- Accessing a value out of bounds causes a runtime panic!
- We'll cover creating, pushing, slicing, and more later

* Function Declarations

    func funcName (arg1 string, arg2 int64) string {
        ...
    }

    func NoArgs () (string, error) {
        ...
    }

    func AllArgsTheSame (arg1, arg2, arg3 string) {
        ...
    }

    func variadicArgs (args ...int64) {
        ...
    }

* Calling Functions

    noReturn()

    foo := returnsValue()

    foo, bar, baz := returnsSeveralValues()

    foo = requiresArguments(arg1, arg2)

    // The blank identifier (_) ignores a value
    foo, _, baz = returnsSeveralValues()

    // Function is in another package
    dir, err := os.Getwd()

* Package declarations

- Every go file must declare a package
- Multiple files can declare the same package (and this is common)
- Typically all the files in one directory share a package
- The package name should match the directory's name
- `github.com/autarch/project/path/to/foo` has a package named `foo`
- Package names are usually lower case without underscores
- Any unicode character is valid

    package математический

* Package main and func main

- The `main` package is used to create an executable
- If a file named `my-great-program.go` contains:

    package main

    func main() {
        ...
    }

- When you run `go build` you get an executable named `my-great-program`

* Importing

- Core packages are imported by name (without a repo):

    package main

    import "os"

- Can import many packages at once:

    package main

    import (
        "encode/json"
        "log"
        "os"
    )

- Package names are the last part of the path, so `encode/json`'s package is `json`

    json.NewDecoder() // not encode/json.NewDecoder()

* Printing Output

- We've seen `log` (`log.Print()`) and `os` (`os.Stdout.WriteString()`)
- Can also use `fmt`

.play gopath/src/github.com/autarch/intro-to-go-class-code/fmt-example/fmt-example.go

* The os Package

- Does a lot of stuff, including syscalls (`chdir`, `symlink`, etc.)
- Defines file and process objects

* Getting Positional Command Line Args

- Use `os.Args`:

.play gopath/src/github.com/autarch/intro-to-go-class-code/os-args-example/os-args-example.go

- Argument 0 is the program name

* Checking Errors

- Go has exceptions, but they're not used for APIs
- Used internally or for unrecoverable errors
- Errors are returned as `Error` type values
- `Error` objects stringify
- If there was no error the value is `nil`

    dir, err := os.Getwd()
    if err != nil {
        log.Fatal(err) // Prints a log message and then calls os.Exit(1)
    }

* Reading Command Line Arguments

- Use `fmt.Sscan` (string scan):

    import (
        "fmt"
        "os"
    )

    var arg1 int64
    _, err := fmt.Sscan(os.Args[1], &arg1)

- `fmt.Sscan` expects a string and a pointer to a variable
- It returns the number of values parsed and an error value
- `&` takes a pointer to the given variable
- "Scans" the string and converts it to whatever type the variable is
- If it can't convert it then it returns an error
- Not very strict - will convert "2 blah blah" to 2
- Good enough for now

* If/Else

- `if` does not use parens

    if foo > 42 {
        ...
    } else if bar < 12 {
        ...
    } else {
        ...
    }

* Compound if Statement

- Very, very common Go idiom:

    if err := someOperation(); err != nil {
        log.Fatal(err)
    }

- The `err` variable is only in scope for the `if` statement and its block

* The log Package

- `log.Print(msg)` - prints `msg`
- `log.Fatal(msg)` - calls `log.Print(msg)` and then calls `os.Exit(1)`
- You will use this in the first exercise
- `log.Panic(msg)` - logs `log.Print(msg)` and then calls `panic()`

* Exercise 1

- `cd`$GOPATH/src/github.com/autarch/intro-to-go-class-exercises/exercise1`
- Open `exercise1.go` in your editor of choice
- Read the instructions

* More Data Structures

* String Operations

- Get the length with `len(s)`
- Many, many functions in the `strings` package
- `strings.Trim()`, `strings.Split()`, `strings.Index()` and many more

* Arrays and Slices

- Arrays are fixed-length, declared in advance, passed by value
- Arrays (and slices) are initialized to a sane "zero" value if not populated

    // Every element is 0
    var b [42]byte

- Slices are like arrays but do not require a length, passed by reference

    var s []string

- Can also populate when declaring and take references to existing slices (or arrays)

    s := []string{"a", "slice", "of", "strings"}
    t := s[0:2]
    // t is {"a", "slice", "of"}
    s[0] = "the"
    // t is {"the", "slice", "of"}

* Arrays and Slice Example

.play gopath/src/github.com/autarch/intro-to-go-class-code/arrays/arrays.go

* The make() Built-in

- `make(Type,`Length)` returns a new slice

.play gopath/src/github.com/autarch/intro-to-go-class-code/arrays/make.go

* Appending to a Slice

.play gopath/src/github.com/autarch/intro-to-go-class-code/arrays/append.go

* Iterating Over a Slice

.play gopath/src/github.com/autarch/intro-to-go-class-code/arrays/iterate.go

* Sorting Slices

.play gopath/src/github.com/autarch/intro-to-go-class-code/arrays/sort.go

- You can make any type sortable by implementing `sort.Interface` for your type
- We'll take about interfaces later

* Maps

- Called hashes or dictionaries in many languages
- Key/value mapping
- In Go, key can be any type that supports comparisons with `==` and `!=`
- Can get the length with `len(m)` just like arrays

* Maps Example

.play gopath/src/github.com/autarch/intro-to-go-class-code/maps/maps.go

* Iterating Over Maps

.play gopath/src/github.com/autarch/intro-to-go-class-code/maps/iterate.go

* Exercise 2

- `cd`$GOPATH/src/github.com/autarch/intro-to-go-class-exercises/exercise2`
- Open `exercise2.go` in your editor of choice
- Read the instructions

* Places to Learn

.link http://golang.org golang.org
- Documentation on the language and core packages
.link http://godoc.org godoc.org
- Third party package listing and documentation

* More To Read

.link http://blog.golang.org/organizing-go-code Organizing Go Code
.link http://blog.golang.org/generate Generating code
